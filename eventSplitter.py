import pandas as pd
import random
import time
import os
import subprocess
import numpy as np
from statistics_counters import get_raw_split_annotations

MAIN_VID_PATH = "Video/"
MAIN_ANN_PATH = "/home/sami/Work/resources/inter-rater/"
MAIN_OUT_VID_PATH = "ExampleOut/"
FOLDER_CHAR = "/"
FFMPEG_COMMAND = "ffmpeg"
ALL_FILES_CSV = "all_filesFeb27.csv"
CODEC = "copy"  ## if there is no nvidia GPU, replace this with the CPU Powered 'libx264'




def split_and_save(rootdir, orig, start, duration, name):  ## **DONE**
    """
    runs command line commands to FFMPEG to clip a video

    arguments:
        rootdir (str): the directory to navigate to, usually whatever allows us to access the video in the 'orig' variable
        orig (str): full path or name of the video to copy from
        start (int/float): start time of clip, in seconds
        duration (int/float): duration of clip, in seconds
        name (str): full path or name of video to be saved

    returns:
        nothing, but the command it runs will create a new video wherever 'name' is, depending on where the function navigated with using 'rootdir'
    """
    subprocess.run(
        [
            FFMPEG_COMMAND,  ## make this point to where ffmpeg is, or if FFMPEG is in PATH then just replace this with FFMPEG
            "-i",
            orig,
            "-ss",
            start,
            "-t",
            duration,
            "-c:v",  ## signifies that we are rencoding video
            CODEC,
            "-qp",
            "16",  ## higher means less quality and lower file size. inverse is true
            rootdir + name,
        ]
    )


def import_data_durations(file_name):  ## **DONE**
    """
    This is the main function to import duration data.  
    
    Cycles through a text file and saves start times and duration in key and dictionary, respectively

    arguments:
        file_name (str): path to the text file

    returns:
        annotation_data (df): a data frame indexed by type of engagment, which contains start and duration stats
    """
    annotation_data = pd.read_csv(
        file_name, "\t", header=None, usecols=[0, 5, 2, 4, 3]
    ).set_index([0, 5])
    try:
        annotation_data = annotation_data.drop(index="default", level=0)
    except:
        pass
    end_time = annotation_data[3].describe().max()
    return annotation_data, end_time


def import_paths_from_txt(txt):  ## **DONE**
    """
    borrowed from data counter, imports lines as elements of a list.

    allows us to store paths in persistent .txt file, and just pull from that

    arguments:
        txt (str): path to text file with paths

    returns:
        out (list): list where elements are paths
    """

    out = pd.read_csv(txt, header=None).values.flatten().tolist()
    return out


def clean_cuts(ms_data, window, kind):  ## NOTE: brand new, merging of two functions
    """
    merge of clean_cuts_percentages and clean_cuts_status.  Output is changed between the two using the 'kind' string

    arguments:
        ms_data (df): data from import_data_ms
        window (int): size of the calculation window, in milliseconds
        kind (str): '%' if you want percentages, 'bool' if you want status (True/False)
    """
    previndex = 0
    output = pd.DataFrame(
        columns=[
            "sequence",
            "on-task",
            "off-task",
            "satisfied",
            "confused",
            "bored",
            "focused",
            "idle",
            "distracted",
        ]
    ).set_index("sequence")
    seq = 0
    for i in range(len(ms_data) + 2):
        if i == 0:
            continue
        if i % window == 0:
            seq += 1
            if kind == "%":
                data = get_percentages(ms_data, window, previndex, i)
            elif kind == "bool":
                data = get_status(ms_data, window, previndex, i)
            previndex = i
            output.loc[seq] = data.loc[0].tolist()
    return output


def import_data_ms(file_name):  ## **DONE**
    '''
    This is the main function to import duration data but IN MILLISECONDS

    Uses the dataframe generated by import_data_duration to populate a dataframe where tag values are indexed to the millisecond

    Important for clean_cuts and associaton_splitter
    
    arguments:
        file_name (str): path to the text file

    returns:
        ms_data (df): a data frame indexed by millisecond, relating to the value of each tag
    '''
    annotation_data, endtime = import_data_durations(file_name)
    tags = [
        "on-task",
        "off-tsak",
        "Bored",
        "Confused",
        "Satisfied",
        "distarcted",
        "idle",
        "focused",
    ]
    tagsMapped = {
        "on-task": (2, "behavior"),
        "off-tsak": (1, "behavior"),
        "Bored": (1, "emotion"),
        "Confused": (2, "emotion"),
        "Satisfied": (3, "emotion"),
        "distarcted": (1, "attention"),
        "idle": (2, "attention"),
        "focused": (3,"attention")
    }
    ms_data = pd.DataFrame(
        0,
        index=(np.arange(int(endtime * 1000))),
        columns=["behavior", "attention", "emotion"],
    )
    for tag in tags:
        try:
            times = annotation_data.xs(tag, level=1).iterrows()
        except:
            continue
        for elem in times:
            start = int(1000 * (elem[1][2]))
            stop = int(1000 * (elem[1][2] + elem[1][4]))
            label = tagsMapped[tag][1]
            val = tagsMapped[tag][0]
            ms_data.loc[start:stop, label] = val

    return ms_data


def get_percentages(df, window, previndex, i): ## **DONE**
    """
    used in clean_cuts to get percentages per window.

    arguments:
        all arguments are inherited from clean_cuts
    """
    behaviorCounts = df[previndex:i]["behavior"].value_counts()
    attentionCounts = df[previndex:i]["attention"].value_counts()
    emotionCounts = df[previndex:i]["emotion"].value_counts()
    percentageDF = pd.DataFrame(
        columns=[
            "on-task",
            "off-task",
            "satisfied",
            "confused",
            "bored",
            "focused",
            "idle",
            "distracted",
        ]
    )
    percentageDF.loc[0] = [0, 0, 0, 0, 0, 0, 0, 0]
    for item in behaviorCounts.iteritems():
        if item[0] == 1:
            percentageDF.loc[0]["off-task"] = item[1] / window
        elif item[0] == 2:
            percentageDF.loc[0]["on-task"] = item[1] / window
    for item in attentionCounts.iteritems():
        if item[0] == 1:
            percentageDF.loc[0]["distracted"] = item[1] / window
        elif item[0] == 2:
            percentageDF.loc[0]["idle"] = item[1] / window
        elif item[0] == 3:
            percentageDF.loc[0]["focused"] = item[1] / window
    for item in emotionCounts.iteritems():
        if item[0] == 1:
            percentageDF.loc[0]["bored"] = item[1] / window
        elif item[0] == 2:
            percentageDF.loc[0]["confused"] = item[1] / window
        elif item[0] == 3:
            percentageDF.loc[0]["satisfied"] = item[1] / window

    return percentageDF


def get_status(df, window, previndex, i): ## **DONE**
    """
    used in clean_cuts to get percentages per window.

    arguments:
        all arguments are inherited from clean_cuts
    """
    behaviorCounts = df[previndex:i]["behavior"].value_counts()
    attentionCounts = df[previndex:i]["attention"].value_counts()
    emotionCounts = df[previndex:i]["emotion"].value_counts()
    statusDF = pd.DataFrame(
        columns=[
            "on-task",
            "off-task",
            "satisfied",
            "confused",
            "bored",
            "focused",
            "idle",
            "distracted",
        ]
    )
    statusDF.loc[0] = [False, False, False, False, False, False, False, False]
    for item in behaviorCounts.iteritems():
        # print(item[1])
        if item[0] == 1 and item[1] > 499:
            statusDF.loc[0]["off-task"] = True
        elif item[0] == 2 and item[1] > 499:
            statusDF.loc[0]["on-task"] = True
    for item in attentionCounts.iteritems():
        if item[0] == 1 and item[1] > 499:
            statusDF.loc[0]["distracted"] = True
        elif item[0] == 2 and item[1] > 499:
            statusDF.loc[0]["idle"] = True
        elif item[0] == 3 and item[1] > 499:
            statusDF.loc[0]["focused"] = True
    for item in emotionCounts.iteritems():
        if item[0] == 1 and item[1] > 499:
            statusDF.loc[0]["bored"] = True
        elif item[0] == 2 and item[1] > 499:
            statusDF.loc[0]["confused"] = True
        elif item[0] == 3 and item[1] > 499:
            statusDF.loc[0]["satisfied"] = True
    return statusDF


def getVideoPath(textPath, locations, extras=False): ## **DONE**
    file_name_splits = os.path.basename(textPath).split(".")[0].split("_")
    p = file_name_splits[0]
    s = file_name_splits[1]
    csv = pd.read_csv(locations, header=None, usecols=[0, 1, 2]).set_index([0, 1])
    vid_folder = csv.xs([p, s]).to_list()[0]
    full_path = MAIN_VID_PATH + p + FOLDER_CHAR + s + FOLDER_CHAR + vid_folder
    found = False
    for file in os.listdir(full_path):
        if file.endswith(".mp4") and file.startswith(p + "_" + s):
            path = os.path.join(full_path, file)
            found = True
            if extras:
                return (path,p,s,)  
            return path
    if not found:
        print("Video file does not exsist")
        return ""
        # raise Exception('Video file does not exsist')


def event_splitter(path, data, window): ## **DONE**
    tags = [
        "on-task",
        "off-tsak",
        "Bored",
        "Confused",
        "Satisfied",
        "distarcted",
        "idle",
        "focused",
    ]
    vPath, p, s = getVideoPath(path, ALL_FILES_CSV, True)
    for tag in tags:
        try:
            times = data.xs(tag, level=1).iterrows()
        except:
            continue
        for elem in times:
            if len(elem) > 1:
                start = elem[1][2] - window
                if start < 0:
                    start = 0
                duration = elem[1][4]
                eventDuration = window * 2
                if start == 0:
                    eventDuration = window
                if duration < window:
                    name = (
                        p
                        + "_"
                        + s
                        + "_"
                        + "event"
                        + "_"
                        + tag
                        + "_B"
                        + str(round(start, 3))
                        + "_"
                        + str(window)
                        + "sINCOMPLETE.mp4"
                    )  # the name has INCOMPLETE because the tag is shorter than the desired window for the event
                    split_and_save(
                        MAIN_OUT_VID_PATH, vPath, str(start), str(eventDuration), name
                    )
                else:
                    name = (
                        p
                        + "_"
                        + s
                        + "_"
                        + "event"
                        + "_"
                        + tag
                        + "_B"
                        + str(round(start, 3))
                        + "_"
                        + str(window)
                        + "s.mp4"
                    )
                    split_and_save(
                        MAIN_OUT_VID_PATH, vPath, str(start), str(eventDuration), name
                    )
                    
                    non_event_splitter(start, duration, window, p, s, tag, vPath, "I")


def non_event_splitter(start, duration, window, p, s, tag, vPath, char): ## **DONE**
    start = start + window
    duration = duration - window
    iterations = (int(duration) // window) + 1
    for i in range(iterations):
        name = (
            p
            + "_"
            + s
            + "_"
            + "non-event"
            + "_"
            + tag
            + "_S"
            + str(round(start, 3))
            + "_"
            + char
            + str(i + 1)
            + "_"
            + str(window)
            + "s.mp4"
        )
        if i == (iterations - 1):
            split_and_save(
                MAIN_OUT_VID_PATH,
                vPath,
                str(start),
                str(duration - (window * (iterations - 1))),
                name,
            )
            break
        split_and_save(MAIN_OUT_VID_PATH, vPath, str(start), str(window), name)
        start = start + window


def association_splitter(path, window):
    data = import_data_durations(path)[0]
    vPath, p, s = getVideoPath(path,ALL_FILES_CSV, True)
    splits = get_raw_split_annotations(data,window)
    prev = ""
    number = 1
    for index, row in splits.iterrows():
        start = index[0]
        duration = index[1] - start
        # print(start,duration)
        if [row["on-task"], row["Satisfied"], row["focused"]] == [True, True, True]:
            if prev == 'NSF':
                number += 1
            else:
                prev = 'NSF'
            
            numbered_splitter(
                start,duration,window,p,s,"on-task_satisfied_focused",vPath,"E",number
            )
            continue

        if [row["off-tsak"], row["Satisfied"], row["focused"]] == [True, True, True]:
            if prev == 'FSF':
                number += 1
            else:
                prev = 'FSF'
            
            numbered_splitter(
                start,duration,window,p,s,"off-task_satisfied_focused",vPath,"E",number
            )
            
            continue

        if [row["off-tsak"], row["Bored"], row["idle"]] == [True, True, True]:
            if prev == 'FBI':
                number += 1
            else:
                prev = 'FBI'
    
            numbered_splitter(
                start,duration,window,p,s,"off-task_bored_idle",vPath,"E",number
            )
            
            continue

        if [row["off-tsak"], row["Bored"], row["distarcted"]] == [True, True, True]:
            if prev == 'FBD':
                number += 1
            else:
                prev = 'FBD'
            numbered_splitter(
                start,duration,window,p,s,"off-task_bored_distracted",vPath,"E",number
            )
            
            continue
        prev = ""
        number = 1


def numbered_splitter(start, duration, window, p, s, tag, vPath, char, number): ## **DONE**
    name = (
        p
        + "_"
        + s
        + "_"
        + "non-event"
        + "_"
        + tag
        + "_S"
        + str(round(start, 3))
        + "_"
        + char
        + str(number)
        + "_"
        + str(window)
        + "s.mp4"
    )
    split_and_save(MAIN_OUT_VID_PATH, vPath, str(start), str(window), name)


if __name__ == "__main__":
    paths = import_paths_from_txt("paths.txt")
    # passes = 100
    # random_paths = random.choices(paths, k=passes)
    path = MAIN_ANN_PATH + paths[0]
    # data, end_time= import_data_durations(path)
    print(path)  
    # print(data)
    
    # onTask = data.xs('on-task',level = 1)
    # for elem in data.xs('on-task',level = 1).iterrows():
    #     print(len(elem)) # [1][2] is start, [1][4] is duration
    # cuts = (clean_cuts(data,3000,'bool'))
    # print(cuts)
    # for i,row in cuts.iterrows():
    #     print(row['on-task'])
    # print(data)
    # path= paths[1]
    # event_splitter(MAIN_ANN_PATH + path,data,3)
    # for path in random_paths:
    #     data = import_data_ms(MAIN_ANN_PATH + path)
    #     cuts = clean_cuts(data,1000,'bool')
    #     print(association_durations(cuts))
    # path = MAIN_ANN_PATH + paths[0]
    # data = import_data_ms(path)
    # with pd.option_context('display.max_rows', None,'display.max_columns',None):
    #     print(cuts) 
    #     print(import_data_ms(path).loc[33079:33082])
        
        
    # splits = (get_raw_split_annotations(data,5))
    # print(path)
    association_splitter(path,3)
    
